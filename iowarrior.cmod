/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Id: iowarrior.cmod,v 1.3 2007-06-13 02:08:00 hww3 Exp $
 */

/*
 * File licensing and authorship information block.
 *
 * Version: MPL 1.1/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Initial Developer of the Original Code is
 *
 * Bill Welliver <hww3@riverweb.com>
 *
 * Portions created by the Initial Developer are Copyright (C) Bill Welliver
 * All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of the LGPL, and not to allow others to use your version
 * of this file under the terms of the MPL, indicate your decision by
 * deleting the provisions above and replace them with the notice
 * and other provisions required by the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL or the LGPL.
 *
 * Significant Contributors to this file are:
 *
 *
 */

/*! @module Public
 */

/*! @module IO
 */

/*! @module IOWarrior
 */

#define _GNU_SOURCE

#include "iowarrior_config.h"
#include "util.h"

#define CONSTANT(Y, X) do{struct svalue * _sv; _sv = malloc(sizeof(struct svalue)); _sv->type = T_INT; _sv->u.integer = X; simple_add_constant(Y, _sv, 0); free(_sv);} while(0);

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>

#include "IOWarriorLib.h"

  typedef struct
  {
    
    int instance;
  } IOWARRIOR_OBJECT_DATA;

/*! @class IOWarrior
 *!
 */
PIKECLASS IOWarrior
{

  EXTRA 
  {
   CONSTANT("kIOWarrior24Interface0", kIOWarrior24Interface0);
   CONSTANT("kIOWarrior24Interface1", kIOWarrior24Interface1);
   CONSTANT("kIOWarrior24PVInterface0", kIOWarrior24PVInterface0);
   CONSTANT("kIOWarrior24PVInterface1", kIOWarrior24PVInterface1);
   CONSTANT("kIOWarrior40Interface0", kIOWarrior40Interface0);
   CONSTANT("kIOWarrior40Interface1", kIOWarrior40Interface1);
   CONSTANT("kIOWarrior56Interface0", kIOWarrior56Interface0);
   CONSTANT("kIOWarrior56Interface1", kIOWarrior56Interface1);
  }
  CVAR IOWARRIOR_OBJECT_DATA * object_data;

/*! @decl void set_interrupt_callback()
 *!
 */
  PIKEFUN void set_interrupt_callback()
  {
//    IOWarriorSetInterruptCallback();
  }

/*! @decl int interface_type_for_index(int index)
PIKEFUN int interface_type_for_index(int index)
{
  IOWarriorListNode *listNode;

  listNode = IOWarriorInterfaceListNodeAtIndex (index);

  pop_stack();

  if(listNode)
    push_int(listNode->interfaceType);
  else push_int(-1);


}

/*! @decl array(int) read_interface0()
 *!
 */
  PIKEFUN array read_interface0()
  {
    char * data;
    int retval;
    int num_elems = 4;
    int x;

    data = malloc(num_elems);

    for(x=0; x<num_elems; x++)
      data[x] = NULL;

    if(data == NULL) Pike_error("read_interface0(): unable to allocate memory.\n");

    retval = IOWarriorReadInterface0(data);

  //  for(x=0; x<num_elems; x++)
  //    printf("%02x\n", (unsigned char)(data[x]));


    for(x=0; x<num_elems; x++)
      push_int((unsigned char)data[x]);

    f_aggregate(num_elems);
  }

/*! @decl array(int) read_interface(int interface, int reportID)
 *!
 */
  PIKEFUN array read_interface(int interface, int reportID)
  {
    char * data;
    int retval;
    int num_elems = 4;
    int x;

    IOWarriorListNode *listNode;

    listNode = IOWarriorInterfaceListNodeAtIndex (interface);

    data = malloc(num_elems);

    for(x=0; x<num_elems; x++)
      data[x] = NULL;

    if(data == NULL) Pike_error("read_interface0(): unable to allocate memory.\n");

    retval = IOWarriorReadFromInterface(listNode->ioWarriorHIDInterface, reportID, num_elems, data);

  //  for(x=0; x<num_elems; x++)
  //    printf("%02x\n", (unsigned char)(data[x]));

    pop_n_elems(args);

    for(x=0; x<num_elems; x++)
      push_int((unsigned char)data[x]);

    f_aggregate(num_elems);
  }
/*! @decl int write_interface0(string d)
 *!
 */
  PIKEFUN int write_interface0(string d)
  {
    int retval;
    retval = IOWarriorWriteInterface0(d->str);

    pop_n_elems(args);

    push_int(retval);
  }

/*! @decl int write_interface(int interface, string d)
 *!
 */
  PIKEFUN int write_interface(int interface, string d)
  {
    int retval;
    IOWarriorListNode *listNode;

    listNode = IOWarriorInterfaceListNodeAtIndex (interface);

    retval = IOWarriorWriteToInterface(listNode->ioWarriorHIDInterface, d->len, d->str);

    pop_n_elems(args);

    push_int(retval);
  }

/*! @decl int interface_list_node(int index)
 *!
 */
  PIKEFUN int interface_list_node(int index)
  {
     IOWarriorListNode * node;
     char * serial;

     node = IOWarriorInterfaceListNodeAtIndex(index);
     if(node == NULL)
       Pike_error("node does not exist!\n");
    
     serial = CFStringGetCStringPtr(node->serialNumber, kCFStringEncodingUnicode);

     printf("device: %s\n", serial);
     pop_stack();
     push_int(node->interfaceType);
  }

/*! @decl int is_present()
 *!
 */
  PIKEFUN int is_present()
  {
    int retval;

    retval = IOWarriorIsPresent();

    push_int(retval);
  }

/*! @decl int count_interfaces()
 *!
 */
  PIKEFUN int count_interfaces()
  {
    int retval;

    retval = IOWarriorCountInterfaces();

    push_int(retval);
  }

  INIT
  {
   int retval;
   IOWARRIOR_OBJECT_DATA * iow;

   iow = malloc(sizeof(IOWARRIOR_OBJECT_DATA));

   THIS->object_data = iow;

   if(iow == NULL) 
     Pike_error("iowarrior_init: out of memory.\n");

    retval = IOWarriorInit();
    if(retval!=0) Pike_error("iowarrior_init: unable to initialize IO Warrior library.\n");
    }
 
  EXIT
  {
    if(THIS->object_data)
      free(THIS->object_data);
  }

}
/*! @endmodule
 */

/*! @endmodule
 */

/*! @endmodule
 */



